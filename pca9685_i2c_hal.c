#include "pca9685_i2c_hal.h"
#include "main.h" // Include main.h to access STM32 HAL definitions and headers

/*
 * In the main.c file (typically generated by STM32 CubeIDE), the global variable
 * for the I2C handle is defined:
 * I2C_HandleTypeDef hi2c1;
 *
 * We declare it here as 'extern' to grant this driver access to the 
 * initialized I2C peripheral handle.
 */
extern I2C_HandleTypeDef hi2c1;

// Define a timeout for I2C operations in milliseconds
#define I2C_TIMEOUT 100 // 100 ms

/**
 * @brief Initializes the low-level I2C Hardware Abstraction Layer.
 * * In the STM32 CubeIDE ecosystem, the function MX_I2C1_Init() is usually 
 * automatically generated and called within the main() function before the 
 * main loop. Therefore, explicit hardware initialization inside this 
 * function is often unnecessary.
 * * This function performs a sanity check to ensure the handle is valid.
 * * @return PCA9685_OK if the I2C handle is valid, PCA9685_ERR otherwise.
 */
int16_t pca9685_i2c_hal_init()
{
    // Verify that the I2C1 instance has been populated/initialized
    if (hi2c1.Instance == NULL)
    {
        return PCA9685_ERR;
    }

    // HAL_I2C_Init(&hi2c1) is assumed to have been called in main()
    return PCA9685_OK;
}

/**
 * @brief Reads data via I2C from the PCA9685 device.
 * * The I2C read sequence typically consists of:
 * 1. A Write operation to send the register address (reg) we wish to read from.
 * 2. A Restart condition (or Stop + Start).
 * 3. A Read operation to retrieve 'count' bytes of data from that register.
 * * @param address The 7-bit I2C address of the PCA9685 device.
 * @param reg Pointer to the register address to start reading from (1 byte).
 * @param data Pointer to the buffer where the read data will be stored.
 * @param count Number of bytes to read.
 * @return PCA9685_OK on success, PCA9685_ERR on transmission/reception failure.
 */
int16_t pca9685_i2c_hal_read(uint8_t address, uint8_t *reg, uint8_t *data, uint16_t count)
{
    HAL_StatusTypeDef status;

    // 1. Transmit the target register address to the device.
    // The STM32 HAL expects the device address to be shifted left by 1 bit.
    status = HAL_I2C_Master_Transmit(&hi2c1, (address << 1), reg, 1, I2C_TIMEOUT);

    if (status != HAL_OK)
    {
        return PCA9685_ERR;
    }

    // 2. Receive 'count' bytes of data from the device starting at the register address sent above.
    // The STM32 HAL handles the Repeated Start condition implicitly or via specific flags if needed,
    // though Master_Receive after Master_Transmit is standard for register reading.
    status = HAL_I2C_Master_Receive(&hi2c1, (address << 1), data, count, I2C_TIMEOUT);

    if (status == HAL_OK)
    {
        return PCA9685_OK;
    }
    else
    {
        return PCA9685_ERR;
    }
}

/**
 * @brief Writes data via I2C to the PCA9685 device.
 * * The high-level PCA9685 driver (pca9685_i2c.c) pre-formats the 'data' buffer
 * to include the register address as the first byte. 
 * Format: [REGISTER_ADDRESS, DATA_BYTE_1, DATA_BYTE_2, ...].
 * * Therefore, this function simply transmits the entire buffer in one go.
 * * @param address The 7-bit I2C address of the PCA9685 device.
 * @param data Pointer to the buffer containing the register address followed by data to write.
 * @param count Total number of bytes to transmit (Register Address + Data length).
 * @return PCA9685_OK on success, PCA9685_ERR on failure.
 */
int16_t pca9685_i2c_hal_write(uint8_t address, uint8_t *data, uint16_t count)
{
    // The STM32 HAL expects the device address to be shifted left by 1 bit.
    if (HAL_I2C_Master_Transmit(&hi2c1, (address << 1), data, count, I2C_TIMEOUT) == HAL_OK)
    {
        return PCA9685_OK;
    }
    else
    {
        return PCA9685_ERR;
    }
}

/**
 * @brief Implements a blocking delay in milliseconds.
 * * Used for waiting for the oscillator to stabilize or for reset timings.
 * This implementation uses the standard STM32 HAL delay function, which depends on the SysTick timer.
 * * @param ms Time in milliseconds to wait.
 */
void pca9685_i2c_hal_ms_delay(uint32_t ms) {
    HAL_Delay(ms);
}
